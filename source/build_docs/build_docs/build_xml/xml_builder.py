# This script gets all of the elements from the EaW and FoC XML files and organizes them for documentation
from os import getcwd

from .xml_classes import *

# Keys are values that are considered booleans, values are suffixes for the type. Capitalization must be lowercase.
VALID_BOOL: dict = {
		"yes": "y/n",
		"no": "y/n",
		"true": "t/f",
		"false": "t/f",
}

# Descriptions for subnodes/attributes. Attribute prefix is "attribute - ". Capitalization must be lowercase for keys.
DESCRIPTORS: dict = {
		"attribute - name": "The name of the node, can be referenced by other nodes",
		"attribute - description": "An optional description for the node, only used to help anyone reading the XML.",
		"text_id": "The in-game name of this unit, references a .DAT file to allow from translations",
		"mass": "Varies between 0 and 1, usually very close to 1. Probably unused.",
		"file": "A file to load, context of loading is based on the root node.",
}

# Default EaW and FoC XML Directories, used when the program is run
DEFAULT_XML_DIR_EAW: str = path.join(getcwd(), "data", "XML")
DEFAULT_XML_DIR_FOC: str = path.join(getcwd(), "data", "corruption", "XML")
DEFAULT_OUTPUT_FILE: str = path.join(getcwd(), "basegame", "xml", "xml_structure.rst")

# Tab character
TAB: str = "\t"
# Used at the end of the line to indicate it has tabbed children, must have a newline at the end to function properly
TAB_INDICATOR: str = "\n"
# Number of "=" signs used for the rows on the Sphinx table.
NUM_TABLE_INDICATORS: int = 65


def build_xml_files() -> None:
	pass


def build(
		xml_dir_eaw: str = DEFAULT_XML_DIR_EAW,
		xml_dir_foc: str = DEFAULT_XML_DIR_FOC,
		xml_dir_out: str = DEFAULT_OUTPUT_FILE,
) -> None:
	"""
	Function to iterate over EaW and FoC XML Files, given both of their XML directories.

	:param xml_dir_eaw: The absolute path to the EaW XML Directory.
	:param xml_dir_foc: The absolute path to the FoC XML Directory.
	:param xml_dir_out: The absolute path to the Documentation directory for XML Files.

	:returns: None, writes to an output file.
	"""

	def build_table_output() -> None:
		def get_table_str(node_name, attributes) -> str:
			table_string = node_name.ljust(NUM_TABLE_INDICATORS)
			table_string += " " + attributes.ljust(NUM_TABLE_INDICATORS)
			return table_string + "\n"

		def codify(string) -> str:
			return "``{}``".format(string)

		def start_table(out_file) -> None:
			out_file.write(table_sep_str)
			out_file.write(get_table_str("Node Name", "Attributes"))
			out_file.write(table_sep_str)

		def write_header(out_file, header, sep) -> None:
			out_file.write(header + "\n")
			out_file.write(str(sep * len(header)) + "\n")

		def write_footer(out_file, lines) -> None:
			out_file.write("\n")
			for line in range(lines):
				out_file.write("| \n")
			out_file.write("\n")

		def write_list_subnode(out_file, list_subnode, list_type) -> None:
			# Copy subnode
			print_subnode = list_subnode

			# Setup Operations
			description = "*Description Here*"
			if print_subnode.startswith("AAA_"):
				print_subnode = print_subnode.replace("AAA_", "")
			if print_subnode.lower() in DESCRIPTORS:
				description = DESCRIPTORS[print_subnode.lower()]

			# Write
			out_file.write("- {}{}".format(print_subnode, TAB_INDICATOR))
			out_file.write(TAB + list_type + "; {}\n".format(description))
			out_file.write("\n")

		# Create string to use for tables
		table_sep_str = ("=" * NUM_TABLE_INDICATORS) + " " + ("=" * NUM_TABLE_INDICATORS) + "\n"

		# Create File
		if not path.exists(output_file):
			open(output_file, "x")

		# Build Table Output XML
		with open(output_file, "wt", newline="\n") as structure_file:
			# Write title
			write_header(structure_file, "All XML Structures - Autogenerated File", "=")

			# Write top-level node table
			for top_level_node in sorted(xml_tree):
				subnode_only = False
				# Write top level node as header
				write_header(structure_file, top_level_node, "-")
				# Check if only subnodes
				for node in xml_tree[top_level_node]:
					if type(xml_tree[top_level_node][node]) is not dict:
						if not subnode_only:
							subnode_only = True

				# Write attribute table if not subnode only, as subnodes cannot have attributes
				if not subnode_only:
					# Start Table
					start_table(structure_file)

					# Write Nodes and attributes in alphabetical order
					for node in sorted(xml_tree[top_level_node]):
						attrib_string = ""
						# Get Attributes
						subnode: str
						for subnode in sorted(xml_tree[top_level_node][node]):
							# Attributes placed first with AAA_ Prefix
							if subnode.startswith("AAA_"):
								attrib_string += codify(subnode.replace("AAA_Attribute - ", "")) + ", "

						# Write string to table, codify values
						if attrib_string == "":
							attrib_string = "None"
						structure_file.write(get_table_str(codify(node), attrib_string.strip(", ")))

					# End table, write blank line(s)
					structure_file.write(table_sep_str)
					write_footer(structure_file, 1)

					# Write top node sections
					# Iterate over nodes
					for node in sorted(xml_tree[top_level_node]):
						write_header(structure_file, node, "^")
						# Begin subnodes
						for subnode in sorted(xml_tree[top_level_node][node]):
							write_list_subnode(structure_file, subnode, xml_tree[top_level_node][node][subnode])
						write_footer(structure_file, 1)

				# Write top node sections immediately if subnode only
				else:
					# Iterate over subnodes
					for subnode in sorted(xml_tree[top_level_node]):
						write_list_subnode(structure_file, subnode, xml_tree[top_level_node][subnode])
				write_footer(structure_file, 2)

	# Setup output file
	output_file: str = path.join(xml_dir_out, "xml_structure.rst")
	xml_type_list: List[XMLType] = []

	# Dataminerxmlfiles.Xml Path
	eaw_data_xml_path: str = path.join(xml_dir_eaw, "Dataminerxmlfiles.Xml")  # TODO: String is .title()d, fix filenames
	# Ensure Dataminerxmlfiles.Xml file exists
	if not path.exists(eaw_data_xml_path):
		raise Exception("'{}' does not exist".format(eaw_data_xml_path))

	foc_data_xml_path: str = path.join(xml_dir_foc, "Dataminerxmlfiles.Xml")  # TODO: String is .title()d, fix filenames
	# Ensure Dataminerxmlfiles.Xml file exists
	if not path.exists(foc_data_xml_path):
		raise Exception("'{}' does not exist".format(eaw_data_xml_path))

	# Parse data files
	eaw_data_xml: xml.etree.ElementTree.Element = ET.parse(eaw_data_xml_path).getroot()
	foc_data_xml: xml.etree.ElementTree.Element = ET.parse(foc_data_xml_path).getroot()
	item: xml.etree.ElementTree.Element

	# Iterate over the data files
	for data_file in (eaw_data_xml, foc_data_xml):
		for item in data_file:
			if item.tag == "File":
				# Get filename
				file: str = path.join(xml_dir_eaw, item.get("filename").strip().title())

				# Get type
				xml_type_str: str = item.get("type").strip()

				# Setup iteration
				prev_type: XMLType
				new: bool = True

				# Iterate over current types
				for prev_type in xml_type_list:
					# Check if names match
					if xml_type_str == prev_type.name:
						# If names match, add to existing
						new = False
						prev_type.add_rootnode(file)
						break
				# If not added earlier, add as new XMLType
				if new:
					# Add to type list
					current_type = XMLType(xml_type_str)
					current_type.add_rootnode(file)
					xml_type_list.append(current_type)
	# Cleanup, delete some variables
	del data_file, current_type, file

	# Define attribute sorting function
	def attrib_sort(x):
		"""
		Sorts attributes first, then eveything else. Uses as key for sorted() function
		:param x: The attribute to input
		:return: Either x or 0 + x
		"""
		if type(x) is str and x.startswith("Attribute - "):
			return "0" + x
		else:
			return x

	# Parse files
	for xtype in xml_type_list:
		xtype.parse_subfiles()


	# Build output as table
	# build_table_output()


if __name__ == "__main__":
	build()

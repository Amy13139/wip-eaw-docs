# This script gets all of the elements from the EaW and FoC XML files and organizes them for documentation

from typing import TextIO

# Includes os.path.join, typing.Dict
from .inserts import *
# Includes os.path, typing.List, typing.Union, typing.Dict, typing.Set, xml.etree.ElementTree as ET
from .xml_classes import *

# Path constants
XML_STRUCTURE_FILENAME: str = "xml_structure.rst"
# Tab character
TAB: str = "\t"
# Used at the end of the line to indicate it has tabbed children, must have a newline at the end to function properly
TAB_INDICATOR: str = "\n"
# Number of "=" signs used for the rows on the Sphinx table.
NUM_TABLE_INDICATORS: int = 65
# Create string to use for tables
TABLE_SEP_STR = ("=" * NUM_TABLE_INDICATORS) + " " + ("=" * NUM_TABLE_INDICATORS) + "\n"


def build_docs(xml_dir_out: str, xml_types: List[XMLType]) -> None:
	"""
	Takes a list of XMLTypes and uses them to build the XML Documentation
	:param xml_dir_out: The output directory, should also be the XML Docs directory
	:param xml_types: The list of XML Types to use for building the documentation
	"""

	def codify(in_str: str) -> str:
		"""
		Cushions a string with four "`" character, used to indicated code in a Sphinx rst file.
		:param in_str: The string to cushion
		:return: The cushioned string
		"""
		return "``{}``".format(in_str)

	def write_line_padding(out_file: TextIO, line_num: int) -> None:
		"""
		Writes line_num blank lines
		:param out_file: The file to write to
		:param line_num: The number of blank lines to write
		"""
		for i in range(line_num):
			out_file.write("\n")

	def write_table_str(out_file: TextIO, item1: str, item2: str) -> None:
		"""
		Writes a string as part of a Sphinx rst table.
		:param out_file: The file to write to
		:param item1: The first item in the table
		:param item2: The second item in the table
		"""
		table_string = item1.ljust(NUM_TABLE_INDICATORS)
		table_string += " " + item2.ljust(NUM_TABLE_INDICATORS)
		out_file.write(table_string + "\n")

	def write_table_start(out_file: TextIO, item1="Node Name", item2="Attributes") -> None:
		"""
		Starts a table in Sphinx rst format.
		:param out_file: The file to write to
		:param item1: The first header in the table
		:param item2: The second header in the table
		"""
		out_file.write(TABLE_SEP_STR)
		write_table_str(out_file, item1, item2)
		out_file.write(TABLE_SEP_STR)

	def write_table_end(out_file: TextIO, line_num: int) -> None:
		"""
		Ends a table in Sphinx rst format.
		:param out_file: The file to write to
		:param line_num: The number of blank lines to write, must be >=1
		"""
		structure_file.write(TABLE_SEP_STR)
		write_line_padding(structure_file, line_num)

	def write_header(out_file: TextIO, header: str, sep: str) -> None:
		"""
		Writes a header in Sphinx rst format.
		:param out_file: The file to write to
		:param header: The text of the header
		:param sep: The separator to use for creating the header
		"""
		out_file.write(header + "\n")
		out_file.write(str(sep * len(header)) + "\n")
		write_line_padding(structure_file, 1)

	def write_list_subnode(out_file: TextIO, subnode_name: str, subnode_type: str) -> None:
		"""
		Writes a subnode in the format for the xml_structure.rst file
		:param out_file: The file to write to
		:param subnode_name: The subnode name to write to the list
		:param subnode_type: The subnode type to write to the list
		"""
		# Get description
		description = get_subnode_description(subnode_name)

		# Write
		out_file.write("- {}{}".format(subnode_name, TAB_INDICATOR))
		out_file.write(TAB + subnode_type + "; {}\n".format(description))
		out_file.write("\n")

	def do_node_iter(out_file: TextIO, curr_node: Node):
		"""
		Writes a node's information in the format for the xml_structure.rst file
		:param out_file: The file to write to
		:param curr_node: The node to use for the writting.
		:return:
		"""

	# Create File
	xml_strucuture_path = join(xml_dir_out, XML_STRUCTURE_FILENAME)
	if not path.exists(xml_strucuture_path):
		open(xml_strucuture_path, "x")

	# Build Structure XML
	with open(xml_strucuture_path, "wt", newline="\n") as structure_file:
		# Write title
		write_header(structure_file, "All XML Structures - Autogenerated File", "*")

		# Iterate over XMLTypes
		for xml_type in sorted(xml_types, key=lambda x: x.name):
			# Write XMLType name as header
			write_header(structure_file, xml_type.name, "=")
			write_table_start(structure_file, "Root Node Name", "")
			for rootnode in xml_type.get_rootnodes():
				write_table_str(structure_file, rootnode.name, "")
			write_table_end(structure_file, 1)

			# Iterate over RootNodes
			for rootnode in xml_type.get_rootnodes():
				# Write RootNode name as header
				write_header(structure_file, rootnode.name, "-")

				# Write SubNodes table for RootNode's Direct Subnodes
				if rootnode.has_subnodes():
					write_table_start(structure_file, "SubNode Name", "Description")
					# Iterate over direct subnodes
					subnode: SubNode
					for subnode in rootnode.get_subnodes():
						write_table_str(structure_file, subnode.name, subnode.get_typestring())
					# Close the table
					write_table_end(structure_file, 1)

				# Write Nodes table for RootNode's Nodes
				if rootnode.has_nodes():
					write_table_start(structure_file, "Node Name", "Description")
					# Iterate over nodes
					for node in rootnode.get_nodes():
						write_table_str(structure_file, codify(node.name), "")
					# Close the table
					write_table_end(structure_file, 1)
				write_line_padding(structure_file, 1)
			write_line_padding(structure_file, 2)



def build(xml_dir_eaw: str, xml_dir_foc: str, xml_dir_out: str) -> None:
	"""
	Function to iterate over EaW and FoC XML Files, given both of their XML directories.

	:param xml_dir_eaw: The absolute path to the EaW XML Directory.
	:param xml_dir_foc: The absolute path to the FoC XML Directory.
	:param xml_dir_out: The absolute path to the Documentation directory for XML Files.

	:returns: None, writes to an output file.
	"""

	# Setup output file
	output_file: str = path.join(xml_dir_out, "xml_structure.rst")
	xml_type_list: List[XMLType] = []

	# Dataminerxmlfiles.Xml Path
	eaw_data_xml_path: str = path.join(xml_dir_eaw, "Dataminerxmlfiles.Xml")  # TODO: String is .title()d, fix filenames
	# Ensure Dataminerxmlfiles.Xml file exists
	if not path.exists(eaw_data_xml_path):
		raise Exception("'{}' does not exist".format(eaw_data_xml_path))

	foc_data_xml_path: str = path.join(xml_dir_foc, "Dataminerxmlfiles.Xml")  # TODO: String is .title()d, fix filenames
	# Ensure Dataminerxmlfiles.Xml file exists
	if not path.exists(foc_data_xml_path):
		raise Exception("'{}' does not exist".format(eaw_data_xml_path))

	# Parse data files
	eaw_data_xml: xml.etree.ElementTree.Element = ET.parse(eaw_data_xml_path).getroot()
	foc_data_xml: xml.etree.ElementTree.Element = ET.parse(foc_data_xml_path).getroot()
	item: xml.etree.ElementTree.Element

	# Iterate over the data files
	for data_file in (eaw_data_xml, foc_data_xml):
		for item in data_file:
			if item.tag == "File":
				# Get filename
				file: str = path.join(xml_dir_eaw, item.get("filename").strip().title())

				# Get type
				xml_type_str: str = item.get("type").strip()

				# Setup iteration
				prev_type: XMLType
				new: bool = True

				# Iterate over current types
				for prev_type in xml_type_list:
					# Check if names match
					if xml_type_str == prev_type.name:
						# If names match, add to existing
						new = False
						prev_type.add_rootnode(file)
						break
				# If not added earlier, add as new XMLType
				if new:
					# Add to type list
					current_type = XMLType(xml_type_str)
					current_type.add_rootnode(file)
					xml_type_list.append(current_type)
	# Cleanup, delete some variables
	del data_file, current_type, file

	# Parse files
	for xtype in xml_type_list:
		xtype.parse_subfiles()

	# Build XML Docs
	build_docs(xml_dir_out, xml_type_list)

